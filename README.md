# Домашнее задание: Резервное копирование баз данных

## Задание 1. Резервное копирование

### 1.1. Восстановление данных за предыдущий день
Для этого используется **полное ежедневное резервное копирование** (full backup).  
Оно позволяет восстановить всю базу в состоянии на конец вчерашнего дня.  
Метод простой в администрировании, но требует больше места и времени.

---

### 1.2. Восстановление данных за час до поломки
В этом случае одних полных бэкапов недостаточно. Нужно сочетание:
- Полный бэкап (раз в день).
- **Инкрементные или дифференциальные бэкапы** для хранения изменений.
- **Журнал транзакций (binlog в MySQL)** — даёт возможность восстановить данные до любого момента, например, за час до сбоя.

Сценарий: восстановить полный бэкап и применить изменения из binlog до нужного времени.

---

### 1.3. Моментальное переключение на работающую базу
Такое возможно, но это уже задача высокой доступности (HA), а не только резервного копирования:
- Настраивается **репликация master–slave или master–master**.
- Включается механизм автоматического **failover** (например, Orchestrator, ProxySQL).
- Возможны решения на уровне кластера (Galera Cluster, Percona XtraDB Cluster).

В этом случае при сбое основной базы система автоматически переключится на реплику, и работа продолжится без заметного простоя.

## Задание 2. PostgreSQL

### 2.1. Пример резервного копирования и восстановления (один вариант)

**Формат `custom`** — удобен, сжатый, поддерживает выборочное/параллельное восстановление.

**Бэкап одной БД:**
```bash
# создаёт сжатый дамп mydb.dump
pg_dump -h 127.0.0.1 -p 5432 -U myuser -F c -Z 6 -f /backups/mydb.dump mydb

Восстановление в новую БД:

# создать пустую БД
createdb -h 127.0.0.1 -p 5432 -U myuser mydb_restored

# восстановить из дампа
pg_restore -h 127.0.0.1 -p 5432 -U myuser \
  -d mydb_restored --clean --if-exists --no-owner /backups/mydb.dump


⸻

2.1.* Автоматизация

cron + ротация:

# /etc/cron.daily/pgdump_mydb
#!/usr/bin/env bash
set -euo pipefail
DB="mydb"
BKDIR="/backups"
TS=$(date +%F_%H%M)
FILE="$BKDIR/${DB}_${TS}.dump"

pg_dump -F c -Z 6 -U myuser "$DB" -f "$FILE"
find "$BKDIR" -type f -name "${DB}_*.dump" -mtime +14 -delete

Рекомендации: использовать ~/.pgpass (права 0600) для пароля, логировать результат и регулярно проверять восстановление (DR-тест).

## Задание 3. MySQL

### 3.1. Инкрементное резервное копирование

В MySQL для инкрементного резервного копирования чаще всего используют **снимки бинарных логов** (binlog).  
Пример (официальная документация):

**Шаг 1. Полный бэкап (mysqldump):**
```bash
mysqldump -u root -p --all-databases --single-transaction --flush-logs --master-data=2 > full_backup.sql

Эта команда:
	•	создаёт полный дамп всех БД,
	•	фиксирует позицию бинарного лога (--master-data),
	•	переключает бинарные логи (--flush-logs).

Шаг 2. Инкрементные бэкапы (binlog):

mysqlbinlog /var/lib/mysql/mysql-bin.000001 > incr_000001.sql
mysqlbinlog /var/lib/mysql/mysql-bin.000002 > incr_000002.sql

⸻

3.1.* Когда реплика выгоднее?

Использование реплики (slave/replica) даёт преимущества:
	•	Минимизация нагрузки: резервные копии можно снимать с реплики, не нагружая production master.
	•	Возможность моментального переключения: если мастер выходит из строя, можно быстро переключить приложения на реплику.
	•	Гибкость восстановления: реплика хранит данные в актуальном виде без необходимости восстанавливать всё из бэкапов.
	•	Быстрая проверка DR: можно протестировать восстановление и обновления на реплике, не трогая боевой сервер.
